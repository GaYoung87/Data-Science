---
title: "4_데이터조작2_데이터 처리 및 가공"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# [1.데이터 처리 및 가공 패키지]
```{r}
install.packages("sqldf")
install.packages("plyr")
install.packages("reshape2")
install.packages("data.table")
install.packages("foreach")
install.packages("doParallel")
install.packages("testthat")
```

```{r}
library(sqldf)
library(plyr)
library(reshape2)
library(data.table)
library(foreach)
library(doParallel)
library(testthat)
```


# [2.SQL을 사용한 데이터처리]
```{r}
# sqldf::sqldf(): 반환값은 데이터프레임
sqldf::sqldf(
  x,                        # SQL SELECT문
  stringsAsFactors = FALSE  # 문자열을 팩터로 반환할지 문자열로 반환할지 여부
)

# 붓꽃 종 확인하기
sqldf("select distinct Species from iris")
#      Species
# 1     setosa
# 2 versicolor
# 3  virginica

# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
# 전체 문장을 ''하고, 안에 것들을 ""로 처리해야함
sqldf('select avg("Sepal.Length") from iris where Species="setosa"')
#   avg(Sepal.Length)
# 1             5.006

mean(subset(iris, Species == "setosa")$Sepal.Length)
# [1] 5.006
```

```{r}
# 종별 Sepal.Length의 평균 구하기: sqldf
sqldf('select Species, avg("Sepal.Length") from iris group by Species')
#      Species  avg(Sepal.Length)
# 1     setosa              5.006
# 2 versicolor              5.936
# 3  virginica              6.588

# 종별 Sepal.Length의 평균 구하기: split, sapply
sapply(split(iris$Sepal.Length, iris$Species), mean)
#    setosa versicolor  virginica 
#     5.006      5.936      6.588
```


# [3.pylr패키지를 이용한 분할, 적용, 재조합을 통한 데이터 분석]
```{r}
# 데이터 분할(split) -> 함수적용(apply) -> 재조합(combine)
# 데이터입력: 배열, 데이터프레임, 리스트
# 데이터출력: 배열, 데이터프레임, 리스트, 아무결과 출력하지않기
# a : 입력, 출력 : 배열 
# d : 입력, 출력 : 데이터프레임
# l : 입력, 출력 : 리스트
# _ :       출력 : 아무런 출력없음
```

# adply(): 배열을 받아 데이터프레임을 반환
```{r}
plyr::adply(
  .data = ,     # 행렬,배열,데이터프레임
  .margins = ,  # 함수적용방향 -> 1(행), 2(열), c(1,2)(행열)
  .fun = NULL   # .margin방향으로 잘려진 데이터에 적용할 함수
)
```

```{r}
# apply() vs adply()
# 1.apply()
#  - 행방향으로 처리할 때 각 컬럼에 서로 다른데이터 타입이 섞여있으면, 예상치 못한 타입변환이 발생할 수 있음
#  - 한가지 타입만 저장할 수 있는 행렬로 결과를 반환하기 때문
apply(iris[,1:4], 1, function(row) {print(row)})  # 모두 숫자 -> 결과: 숫자
apply(iris, 1, function(row) {print(row)})  # 숫자+문자 -> 결과: 문자

# 2.adply()
# 조건에 맞으면 결과를 새로운 컬럼에 기록하는 예
adply(iris,
      1,
      function(row) {row$Sepal.Length >= 5.0 &
                     row$Species == "setosa"})
# 기존 의 모양에 컬럼추가
#   Sepal.Length  Sepal.Width Petal.Length  Petal.Width   Species      V1  
# 1          5.1          3.5          1.4          0.2    setosa    TRUE
# 2          4.9          3.0          1.4          0.2    setosa   FALSE
# 3          4.7          3.2          1.3          0.2    setosa   FALSE

# 위와 같은 작업 후 함수 내부에서 데이터 프레임으로반환
adply(iris,
      1,
      function(row) {
        data.frame(sepal_ge_5_setosa = c(row$Sepal.Length >= 5.0 &
                     row$Species == "setosa"))})
# 새로운 데이터 프레임
#   Sepal.Length  Sepal.Width Petal.Length  Petal.Width   Species      V1  
# 1          5.1          3.5          1.4          0.2    setosa    TRUE
# 2          4.9          3.0          1.4          0.2    setosa   FALSE
# 3          4.7          3.2          1.3          0.2    setosa   FALSE
```

# ddply()
```{r}
plyr::ddply(
  .data = ,
  .variables = ,  # 데이터를 그룹 지을 변수명
  .fun = NULL
)

# adply(): 행또는 컬럼단위로 함수 적용
# ddply(): .variales에 나열한 컬럼에 따라 데이터를 나눈뒤 함수를 적용
plyr::ddply(iris,
            .(Species),
            function(sub) {
              data.frame(sepal.width.mean = mean(sub$Sepal.Width))})
#      Species   sepal.width.mean
# 1     setosa              3.428
# 2 versicolor              2.770
# 3  virginica              2.974

# 여러변수로 그룹짓기
plyr::ddply(iris,
            .(Species, Sepal.Length > 5.0),
            function(sub) {
              data.frame(sepal.width.mean = mean(sub$Sepal.Width))})
#      Species  Sepal.Length > 5.0  sepal.width.mean
# 1     setosa               FALSE           3.20357
# 2     setosa                TRUE           3.71354
# 3 versicolor               FALSE           2.23333
# 4 versicolor                TRUE           2.80426
# 5  virginica               FALSE           2.50000
# 6  virginica                TRUE           2.98367
```

```{r}
# baseball데이터: 선수id가 해당연도year에 기록한 성적이 들어있다.
head(baseball)
head(subset(baseball, id == "ansonca01"))

str(baseball)  # id, year, stint, team, lg, g, ab, r, h, X2b ,,,
# ddply()를 이용해 각 선수가 출전한 게임 수의 평균을 구하자.
# id를 사용해 그룹을 짓고, 분할된 그룹마다 g의 평균을 계산한다.
ddply(baseball, .(id), function(sub) {mean(sub$g)})
#          id         V1
# 1 aaronha01  143.39130
# 2 abernte02   40.05882
# 3 adairje01   77.66667
# 4 adamsba01  115.23529
# ...
```

# 그룹마다 연산을 쉽게 수행하기
```{r}
# base::transforn(): 객체 변환
# 데이터프레임 data에 ...에 지정한 연산을 수행한 뒤 그 결과를 저장한 새로운 컬럼을 추가한 데이터 프레임 반환
base::transform(
  data,  # 변환할 객체
  ...    # 테그 = 값 형태의 인자들
)

# 데이터를 선수id로 분할하여 그룹지은 후, 각 그룹에서 year의 최솟값과 현재행의 year차이를 cyear에 저장하기
head(ddply(baseball, .(id), transform, cyear = year - min(year) + 1))
#          id year stint team lg   g  ab   r   h X2b X3b hr rbi sb cs bb so ibb hbp sh sf gidp cyear
# 1 aaronha01 1954     1  ML1 NL 122 468  58 131  27   6 13  69  2  2 28 39  NA   3  6  4   13     1
# 2 aaronha01 1955     1  ML1 NL 153 602 105 189  37   9 27 106  3  1 49 61   5   3  7  4   20     2
# 3 aaronha01 1956     1  ML1 NL 153 609 106 200  34  14 26  92  2  4 37 54   6   2  5  7   21     3
# 4 aaronha01 1957     1  ML1 NL 151 615 118 198  27   6 44 132  1  1 57 58  15   0  0  3   13     4
# 5 aaronha01 1958     1  ML1 NL 153 601 109 196  34   4 30  95  4  1 59 49  16   1  0  3   21     5
# 6 aaronha01 1959     1  ML1 NL 154 629 116 223  46   7 39 123  8  0 51 54  17   4  0  9   19     6
```

```{r}
# plyr::mutate(): 데이터프레임에 새로운 컬럼을 추가하거나 기존 컬럼 수정
plyr::mutate(
  .data,  # 변환할 데이터 프레임
  ...     # 새로운 컬럼 정의. 컬럼명 = 값 형식 
)

# base::transform()을 개선한 plyr::mutate()
# 여러컬럼을 데이터 프레임에 추가할 때 바로 앞서 추가한 컬럼을 뒤에 추가하는 컬럼에서 참조할 수 있음
head(ddply(baseball, .(id), mutate, cyear = year - min(year) + 1, log_cyear = log(cyear)))
```

```{r}
# plyr::summarise(): 데이터프레임 요약
plyr::summarise(
  .data,  # 요약할 데이터 프레임
  ...     # 변수=값 형태의 인자들
)

# 선수의 최초 데이터가 몇년도인지 확인
head(ddply(baseball, .(id), summarise, minyear = min(year), maxyear = max(year)))
```

```{r}
# base::subset(): 벡터, 행렬, 데이터프레임의 일부 반환
base::subset(
  x,       # 일부를 택할 데이터
  subset,  # 데이터를 선택할지 여부를 지정한 논리값 벡터
  select   # 선택할 컬럼의 벡터, 제외할 컬럼은 - 붙이기
)

# 선수별로 가장 많은 수의 게임을 플레이한 해의 기록을 찾기
head(ddply(baseball, .(id), subset, g==max(g)))
```

# mdply(): 데이터 프레임이나 배열에 저장된 인자로 함수를 호출하고 결과를 데이터프레임으로 반환
```{r}
plyr::mdply(
  .data = ,  # 인자로 사용할 행렬 또는 데이터프레임
  .fun =     # 호출하 함수
)

# 평균과 표준편차를 저장한 데이터프레임
x <- data.frame(mean=1:5, sd=1:5)

# rnorm(): 평균이 mean이고 표준편차가 sd인 n개의 난수를 발생시키는 함수
mdply(x, rnorm, n=2)
#   mean sd        V1         V2
# 1    1  1  2.931512 -0.2720339
# 2    2  2  3.969422  4.8632019
# 3    3  3 -1.712844  0.5427824
# 4    4  4  7.699660  5.1748210
# 5    5  5  8.057774 15.6745273
```


# [4.데이터 구조의 변형과 요약]
# 개요
```{r}
# reshape2는 데이터의 모양을 바꾸거나, 그룹별 요약값을 계산하는 함수를 담고있음
# 변환된 데이터는 측정치를 variable과 value라는 두 컬럼으로 표현 -> 데이터의 통계치 계산이 편리
head(french_fries)
colnames(french_fries)
# "time": 몇주차 실험, "treatment": 사용한 식용류 종류, "subject": 실험대상자
# "rep": 같은내용 여러번 측정, "potato": 감자맛, "buttery": 버터맛,
# "grassy": 풀맛, "rancid": 신맛, "painty": 안좋은냄새
```

# melt(): 식별자id, 측정변수 variable, 측정치 value형태로 데이터 재구성
```{r}
reshape2::melt.data.frame(
  data = ,          # melt할 데이터
  id.vars = ,       # 식별자 컬럼들
  measure.vars = ,  # 측정치 컬럼들, 이 값이 생략되면 id.vars에 해당하지 않는 모든 컬럼이 측정치 컬럼으로 취급
  na.rm = FALSE     # NA인 행을 결과에 포함시킬지 여부. FALSE는 NA를 제거하지 않음
)

# french_fries에서 식별자 가능부분: time, treatment, subject, rep
# french_fries에서 측정변수와 측정값 가능부분: potato, buttery, grassy, rancid, painty
m <- melt(french_fries, id.vars = 1:4)
head(m, 3)
#   time treatment subject rep variable value
# 1    1         1       3   1   potato   2.9
# 2    1         1       3   2   potato  14.0
# 3    1         1      10   1   potato  11.0

# 여러 컬럼으로 나열된 측정치들을 variable, value두개 컬럼을 사용해 여러행으로 변환하는 것
# 이렇게 되면, variable마다 그룹 지어 통계치 계산작업이 간단

# 식용유treatment마다 측정 변수의 평균을 구하는 코드
ddply(m, .(variable), summarise, mean = mean(value, na.rm=TRUE))
#   variable      mean
# 1   potato 6.9525180
# 2  buttery 1.8236994
# 3   grassy 0.6641727
# 4   rancid 3.8522302
# 5   painty 2.5217579
```

```{r}
# complete.cases -> 행의 모든 값이 NA가 아닌경우 TRUE, 하나라도 NA를 포함하면 FALSE
french_fries[!complete.cases(french_fries), ]

# NA를 포함하는 측정치를 melt()시 제외하려면, na.rm = TRUE
m <- melt(id = 1:4, french_fries, na.rm = TRUE)
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

