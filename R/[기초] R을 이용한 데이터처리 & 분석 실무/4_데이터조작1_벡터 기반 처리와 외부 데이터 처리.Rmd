---
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# [1.iris데이터] (분류에 적합한 데이터)
```{r}
head(iris)
str(iris)

iris3  # 3차원 배열형태로 저장
```


# [2.파일입출력]
# csv파일 입출력
```{r}
# csv파일을 데이터프레임으로 읽기
read.csv(
  file,
  header = FALSE,
  na.strings = "NA",  # 기본값은 "NA", "NA"로 저장된 문자열들은 R의 NA로 저장
  stringsAsFactors = default.stringsAsFactors()  # 문자열을 팩터로 저장할지, 문자열로 저장할지 지정, 기본=TRUE
)

# 데이터프레임을 csv로 저장
write.csv(
  x, 
  file = "",
  row.names = TRUE  # TRUE이면 행 이름을 csv파일에 포함해 저장
)
```

```{r}
a <- read.csv("a.csv")
str(a)

b <- read.csv("b.csv")
names(b) <- c("id", "name", "score")
str(b)  # name이 factor형태
x$name <- as.character(x$name)

# 처음부터 문자열을 팩터가 아닌 문자열 타입으로 인식
a_string <- read.csv("a.csv", stringsAsFactors = FALSE)
str(a_string)

# 숫자 들어와야하는 곳에 문자 -> NA처리
c <- read.csv("c.csv", na.strings = c("NIL"))

write.csv(c, "d.csv", row.names = FALSE)
# row.names = FALSE이면 앞에 순서를 나타내는 열이 존재하지 않음
# row.names를 지정하지 않으면 순서를 나타내는 열이 생긴채로 csv파일로 저장됨
```

# 객체의 파일 입출력
```{r}
# save: 저장
save(
  ...,                 # 저장할 객체의 이름
  list = character(),  # 저장할 객체의 이름을 벡터로 지정할 경우 ... 대신 사용
  file                 # 파일명
)

# load: 파일로부터 객체를 메모리로 읽어들인다
load(
  file  # 파일명
)
```

```{r}
rm(list = ls())
a <- 1:5
b <- 6:10
c <- 11:15
save(list = ls(), file = "abc.RData")
```

```{r}
rm(list = ls())
ls()  # character(0)

load("abc.RData")
ls()  # [1] "a" "b" "c"
```


# [3.데이터프레임의 행과 컬럼 합치기]
# rbind
```{r}
rbind(c(1, 2, 3), c(4, 5, 6))
#      [,1] [,2] [,3]
# [1,]    1    2    3
# [2,]    4    5    6

x <- data.frame(id=c(1, 2), name=c("a", "b"), stringsAsFactors=F)
y <- rbind(x, c(3, "c"))
y
#   id  name
# 1  1     a
# 2  2     b
# 3  3     c
```

# cbind
```{r}
cbind(c(1, 2, 3), c(4, 5, 6))
y <- cbind(x, greek=c("alpha", "beta"))
y <- cbind(x, greek=c("alpha", "beta"), stringsAsFactors=F)

# 데이터 프레임에 새로운 컬럼을 추가: cbind( )를 사용하지 않고 df$colname <- data 형태로도 추가 가능
```


# [4.apply 계열함수]
# apply()
#  - 배열 또는 행렬에 주어진 함수를 적용한 뒤 그 결과를 벡터, 배열, 리스트로 반환
#  - 배열 또는 행렬에 적용
#  - 행렬의 행 또는 열방향으로 특정 함수를 적용
```{r}
apply(
  X,          # 배열 또는 행렬
  MARGIN = ,  # 함수 적용 방향: 1=행, 2=열, c(1,2)는 행과열 모두 의미
  FUN =       # 적용함수
)
# 반환값
# 1. FUN이 길이 1인 벡터들을 반환한 경우 벡터
# 2. FUN이 길이 1보다 큰 벡터들을 반환한 경우 행렬
# 3. FUN이 서로 다른 길이의 벡터들을 반환한 경우 리스트
```

```{r}
d <- matrix(1:9, ncol = 3)
d

apply(d, 1, sum)
apply(d, 2, sum)
```

```{r}
head(iris)

apply(iris[,1:4], 2, sum)
# Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
#        876.5        458.6        563.7        179.9

colSums(iris[,1:4])  # 바로 위의 apply와 동일한 결과
# colSums(), colMeans(), rowSums(), rowMeans() 존재
```

# lapply()
#  - list반환
```{r}
lappy(
  X,    # 벡터,리스트,표현식,데이터 프레임
  FUN,  # 적용할 함수
  ...   # 추가인자, 이 인자들은 FUN에 전달
)

# unlist: 리스트를 벡터로 변환(반환값 벡터)
unlist(
  X,                  # R객체, 보통 리스트 또는 벡터 
  recursive = FALSE,  # x에 포함된 리스트 역시 재귀적으로 변환할지 여부
  use.names = TRUE    # 리스트 내 값의 이름을 보존할지 여부
)

# do.call: 함수를 리스트로 주어진 인자에 적용하여 결과반환(반환값 호출결과)
do.call(
  what = ,  # 호출할 함수
  args =    # 함수에 전달할 인자의 리스트
)
```

```{r}
result <- lapply(1:3, function(x) {x*2})
result
# [[1]]
# [1] 2
# 
# [[2]]
# [1] 4
# 
# [[3]]
# [1] 6

result[[1]]
# [1] 2

unlist(result)  # [1] 2 4 6

lapply(iris[, 1:4], mean)
# $Sepal.Length
# [1] 5.843333
# 
# $Sepal.Width
# [1] 3.057333
# 
# $Petal.Length
# [1] 3.758
# 
# $Petal.Width
# [1] 1.199333
```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

