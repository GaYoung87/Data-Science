knitr::opts_chunk$set(echo = TRUE)
# 팩터값 생성
# factor(x, levels, ordered)  # ordered: TRUE=순서형, FALSE=명목형, 기본값=FALSE
sex <- factor("m", c("m", "f"), FALSE)
sex
# 팩터값 생성
# factor(x, levels, ordered)  # ordered: TRUE=순서형, FALSE=명목형, 기본값=FALSE
sex <- factor("m", c("m", "f"))
sex
# 4.펙터인지 판단: is.factor(x)
is.factor(sex)
# [순서형데이터]
# 5.순서형 팩터 생성: ordered(x)
ordered("a", c("a", "b", "c"))
length(x1)
x1 <- c("a", "b", "c")
length(x1)
nrow(x1)
NROW(x1)
# 2.합집합 구하기
union(xx, yy)
xx <- c(1, 2, 3)
yy <- c(1, 3, 4)
# 1.동일한지 판단
identical(xx, yy)
# 2.합집합 구하기
union(xx, yy)
# 6.포함여부확인
"d" %in% xx
# 7.연산자
x <- c(1, 2, 3, 4, 5)
10 - x
setequal(c("a", "b", "c"), c("a", "b", "c", "c"))
identical(c("a", "b", "c"), c("a", "b", "c", "c"))
# 주어진 객체의 길이만큼 시퀀스 생성
# seq_along(along.with = )
x <- c(2, 4, 6, 8, 10)
1:NROW(x)
seq_along(x)
# 반복된 값 저장
rep(1:2, times = 5)
rep(1:2, each = 5)
req(1:2, each = 5, times = 5)
req(1:2, each = 5, times = 2)
# 반복된 값 저장
rep(1:2, times = 5)  # [1] 1 2 1 2 1 2 1 2 1 2
rep(1:2, each = 5)   # [1] 1 1 1 1 1 2 2 2 2 2
rep(1:2, each = 5, times = 2)
x <- list(name = "foo", height = c(1, 3, 5))
x
# 중첩 가능
list(a = list(val = c(1, 2, 3)), b = list(val = c(1, 2, 3, 4)))
matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3)
knitr::opts_chunk$set(echo = TRUE)
matrix(1:9, nrow=3, dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
colnames(x) <- c("col1", "col2", "col3")
colnames(x) <- c("col1", "col2", "col3")
colnames <- (x, c("col1", "col2", "col3"))
colnames(x) <- (x, c("col1", "col2", "col3"))
colnames(x) <- c("col1", "col2", "col3")
rownames(x) <- c("col1", "col2", "col3")
x <- matrix(1:9, nrow=3, ncol=3,dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
rownames(x) <- c("col1", "col2", "col3")
x
x <- matrix(1:9, nrow=3, ncol=3,dimnames = list(c("r1", "r2", "r3"), c("c1", "c2", "c3")))
colnames(x) <- c("col1", "col2", "col3")
x
# 전치행렬
t(x)
mat <- matrix(c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3)
# 전치행렬
t(mat)
mat
# 전치행렬
t(mat)
dim(matt)
# 차원 확인 및 변경
matt <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 3)
dim(matt)
dim(matt) <- c(3, 2)
matt
# 차원 확인 및 변경
matt <- matrix(c(1, 2, 3, 4, 5, 6), ncol = 3)
matt
# 3 x 4배열
array(1:12, dim = c(3, 4))
# 2 x 2 x 3배열
array(1:12, dim = c(2, 2, 3))
# 엑셀의 스프레드시트라고 생각
d <- data.frame(x = c(1, 2, 3, 4, 5),
y = c(2, 4, 6, 8, 10),
z = c("m", "f", "m", "f", "m"))
d
View(d)
View(d)
str(d)
# 엑셀의 스프레드시트라고 생각
d <- data.frame(x = c(1, 2, 3, 4, 5),
y = c(2, 4, 6, 8, 10),
z = c("M", "F", "M", "F", "M"))
str(d)
# 엑셀의 스프레드시트라고 생각
d <- data.frame(x = c(1, 2, 3, 4, 5),
y = c(2, 4, 6, 8, 10),
z = c("M", "F", "M", "F", "M"),
stringsAsFactors = default.stringsAsFactors())
str(d)
# 엑셀의 스프레드시트라고 생각
d <- data.frame(x = c(1, 2, 3, 4, 5),
y = c(2, 4, 6, 8, 10),
z = c("M", "F", "M", "F", "M"))
str(d)
data_frame1[, c("x"), drop=FALSE]
data_frame1 <- data.frame(x = c(1, 2, 3, 4, 5),
y = c(2, 4, 6, 8, 10))
data_frame1[, c("x"), drop=FALSE]
data_frame1 <- data.frame(x = c(1, 2, 3, 4, 5),
y = c(2, 4, 6, 8, 10))
result1 <- data_frame1[, c("x"), drop=FALSE]
result2 <- data_frame1[, c("x")]
result1
View(result1)
View(result1)
result2
result1 <- data_frame1[, c("x"), drop=TRUE]
result1
data_frame2 <- data.frame(a=1:3, b=4:6, c=7:9)
d[, names(d) %in% c("b", "c")]
knitr::opts_chunk$set(echo = TRUE)
# ifelse()
x <- c(1, 2, 3, 4, 5)
ifelse(x%%2 == 0, "even", "odd")
# while()
i <- 0
while (i <= 9) {
i <- i+1
if (i %% 2 != 0) {
next  # print()를 실행하지 않고 while문의 처음으로 감
}
print(i)
}
# repeat
i <- 1
repeat {
print(i)
if (i >= 10) {
break
}
i <- i+1
}
# repeat
i <- 1
repeat {
print(i)
if (i >= 10) {
print("y")
break
}
i <- i+1
}
# repeat
i <- 1
repeat {
print(i)
if (i >= 10) {
print("y")
break
}
i <- i+1
print('n')
}
knitr::opts_chunk$set(echo = TRUE)
subset(iris, Species == "setosa")
# 조건만족하는 행의 색인 반환
which(iris$Species == "setosa")
aggregate(Sepal.Width ~ Species, iris, mean)
# 같은결과
tapply(iris$Sepal.Width, iris$Species, mean)
x <- data.frame(a=c(3,2,9),
b=c(5,3,2),
c=c(4,5,7))
x_stacked <- stack(x)
x
x_stacked
View(x_stacked)
View(x_stacked)
summaryBy(values ~ ind, x_stacked)
library(doBy)
install.packages("doBy")
library(doBy)
stack(
x  # 리스트 또는 데이터 프레임
)
x <- data.frame(a=c(3,2,9),
b=c(5,3,2),
c=c(4,5,7))
x_stacked <- stack(x)  # 세로로 변환
summaryBy(values ~ ind, x_stacked)
unstack(x_stacked, values~idx)
unstack(x_stacked, values~ind)
knitr::opts_chunk$set(echo = TRUE)
install.packages("reshape2")
install.packages("reshape2")
install.packages("data.table")
install.packages("foreach")
install.packages("foreach")
install.packages("doParallel")
install.packages("testthat")
library(sqldf)
library(plyr)
library(reshape2)
library(data.table)
library(foreach)
library(doParallel)
library(testthat)
sqldf("select distinctSpecies from iris")
sqldf("select distinct Species from iris")
a <- sqldf("select distinct Species from iris")
a
View(a)
View(a)
a <- sqldf("select Species from iris")
a
View(a)
View(a)
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
sqldf("select avg(Sepal_Length) from iris where Species='setosa'")
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
sqldf("select avg(Sepal.Length) from iris where Species='setosa'")
View(iris)
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
sqldf("select avg(Sepal.Length) from iris")
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
sqldf("select * from iris where Species='setosa'")
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
View(sqldf("select * from iris where Species='setosa'"))
sqldf("select Seapl.Length from iris")
sqldf("select Sepal.Length from iris")
sqldf("select Sepal_Length from iris")
sqldf("select Sepal-Length from iris")
sqldf("select SepalLength from iris")
sqldf("select Sepa_lLength from iris")
sqldf("select Sepal_Length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select sepal_length from iris")
sqldf("select 'sepal_length' from iris")
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
View(sqldf("select avg('Sepal_Length') from iris where Species='setosa'"))
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
View(sqldf("select avg('Sepal_Length') from iris where Species='setosa'"))
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
sqldf("select avg('Sepal_Length') from iris where Species='setosa'")
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
sqldf('select avg("Sepal_Length") from iris where Species="setosa"')
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
View(sqldf('select avg("Sepal_Length") from iris where Species="setosa"'))
# setosa에 속하는 데이터에서 Sepal.Length의 평균을 구하기
View(sqldf('select avg("Sepal.Length") from iris where Species="setosa"'))
mean(subset(iris, Species == "setosa")$Sepal.Length)
# 종별 Sepal.Length의 평균 구하기
sqldf('select Species, avg("Sepal.Length") from iris group by Species')
# 종별 Sepal.Length의 평균 구하기
View(sqldf('select Species, avg("Sepal.Length") from iris group by Species'))
# 종별 Sepal.Length의 평균 구하기: split, sapply
sapply(split(iris$Sepal.Length, iris$Species), mean)
# apply() vs adply()
# apply(): 행방향으로 처리할 때 각 컬럼에 서로 다른데이터 타입이 섞여있으면, 예상치 못한 타입변환이 발생할 수 있음
apply(iris[,1:4], 1, function(row) {print(row)})
# apply() vs adply()
# apply(): 행방향으로 처리할 때 각 컬럼에 서로 다른데이터 타입이 섞여있으면, 예상치 못한 타입변환이 발생할 수 있음
apply(iris[,1:4], 1, function(row) {print(row)})
# apply() vs adply()
# apply(): 행방향으로 처리할 때 각 컬럼에 서로 다른데이터 타입이 섞여있으면, 예상치 못한 타입변환이 발생할 수 있음
head(apply(iris[,1:4], 1, function(row) {print(row)}))
# 2.adply()
# 조건에 맞으면 결과를 새로운 컬럼에 기록하는 예
adply(iris,
1,
function(row) {row$Sepal.Length >= 5.0 &
row$Species == "setosa"})
# 위와 같은 작업 후 함수 내부에서 데이터 프레임으로반환
adply(iris,
1,
function(row) {
data.frame(sepal_ge_5_setosa = c(row$Sepal.Length >= 5.0 &
row$Species == "setosa"))})
knitr::opts_chunk$set(echo = TRUE)
# adply(): 행또는 컬럼단위로 함수 적용
# ddply(): .variales에 나열한 컬럼에 따라 데이터를 나눈뒤 함수를 적용
ddply(iris,
.(Species),
function(sub) {
data.frame(sepal.width.mean = mean(sub$Sepal.Width))
})
# adply(): 행또는 컬럼단위로 함수 적용
# ddply(): .variales에 나열한 컬럼에 따라 데이터를 나눈뒤 함수를 적용
plyr::ddply(iris,
.(Species),
function(sub) {
data.frame(sepal.width.mean = mean(sub$Sepal.Width))})
# adply(): 행또는 컬럼단위로 함수 적용
# ddply(): .variales에 나열한 컬럼에 따라 데이터를 나눈뒤 함수를 적용
plyr::ddply(iris,
(Species),
function(sub) {
data.frame(sepal.width.mean = mean(sub$Sepal.Width))})
# adply(): 행또는 컬럼단위로 함수 적용
# ddply(): .variales에 나열한 컬럼에 따라 데이터를 나눈뒤 함수를 적용
plyr::ddply(iris,
.(Species),
function(sub) {
data.frame(sepal.width.mean = mean(sub$Sepal.Width))})
# adply(): 행또는 컬럼단위로 함수 적용
# ddply(): .variales에 나열한 컬럼에 따라 데이터를 나눈뒤 함수를 적용
plyr::ddply(iris,
.("Species"),
function(sub) {
data.frame(sepal.width.mean = mean(sub$Sepal.Width))})
# baseball데이터: 선수id가 해당연도year에 기록한 성적이 들어있다.
head(subset(baseball, id == "ansonca01"))
# baseball데이터: 선수id가 해당연도year에 기록한 성적이 들어있다.
head(baseball)
